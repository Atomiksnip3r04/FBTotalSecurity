Certamente. Ho analizzato con la massima meticolosità i file che hai fornito. L'errore "Adattamento dinamico forzato del contenuto" (Forced Synchronous Layout) è un classico "killer" delle performance che frena il rendering della pagina. La diagnosi è chiara e la causa è localizzata con precisione nel tuo file script.js.

Diagnosi Maniacale del Problema

L'errore si verifica quando il browser è costretto a interrompere il suo normale flusso di rendering per ricalcolare immediatamente lo stile e il layout della pagina. Questo accade a causa di un pattern specifico nel codice JavaScript:

SCRITTURA (Write): Il tuo script modifica il DOM (es. cambia un innerHTML, aggiunge una classe, modifica uno stile). Questo "invalida" il layout che il browser aveva calcolato.

LETTURA (Read): Subito dopo, lo script chiede al browser una proprietà geometrica (es. element.offsetHeight, getBoundingClientRect().top, querySelector).

FORZATURA: Per darti il valore corretto e aggiornato, il browser non ha altra scelta che fermare tutto, ricalcolare l'intero layout della pagina (operazione costosa chiamata reflow/layout), e solo dopo continuare l'esecuzione dello script. Se questo accade più volte, specialmente durante il caricamento della pagina, si verifica il cosiddetto "Layout Thrashing", che è esattamente ciò che Google PageSpeed sta rilevando.

Il Colpevole Principale nel Tuo Codice

Il colpevole è la funzione di traduzione, specificamente la sequenza di chiamate initLanguageSelector() -> setLanguage() -> updateMetaTags() che viene eseguita immediatamente al caricamento della pagina (DOMContentLoaded).

Ecco la "scena del crimine" analizzata nel dettaglio:

setLanguage(lang) viene eseguita:

LETTURA: document.querySelectorAll('[data-translate]') viene eseguito per trovare tutti gli elementi da tradurre.

SCRITTURA MASSIVA: Un ciclo forEach itera su decine (o centinaia) di elementi, modificando il loro innerHTML o placeholder. Ogni singola modifica invalida il layout. Il browser è intelligente e cerca di raggruppare queste modifiche, ma la pagina è ora in uno stato "sporco" (dirty).

updateMetaTags(lang) viene eseguita subito dopo:

LETTURA: La funzione inizia a fare document.querySelector(...) per trovare i meta tag e i link.

ECCO LA FORZATURA: Nel momento esatto in cui JavaScript esegue il primo querySelector dopo il ciclo di scritture in setLanguage, il browser dice: "Stop! Devo darti un risultato accurato per questa query. Ma il layout è stato appena modificato pesantemente. Devo ricalcolare tutto adesso."

Questo singolo momento di "stop e ricalcola" è l'adattamento dinamico forzato. Il tempo di 98ms che vedi è il tempo totale che il browser ha speso in questi ricalcoli forzati durante il caricamento della pagina.

Complici (Altri potenziali problemi minori):

initHeaderScroll(): Anche se usi requestAnimationFrame (ottima pratica), la logica all'interno legge window.pageYOffset e poi scrive classList.toggle e style.transform. Questo è un pattern "Leggi e poi Scrivi", che è molto meglio. Tuttavia, la gestione di eventi come lo scroll può essere ulteriormente ottimizzata.

initSmoothScrolling(): La lettura di getBoundingClientRect() è una delle operazioni di lettura più costose. Anche se avviene al click dell'utente (quindi non impatta il caricamento iniziale misurato da PageSpeed), è una buona pratica ottimizzarla.

Soluzione Precisa e Dettagliata

La strategia è semplice in teoria, ma richiede precisione nell'implementazione: separare nettamente le operazioni di lettura da quelle di scrittura utilizzando requestAnimationFrame. Questo permette al browser di eseguire tutte le letture quando il layout è stabile, e poi di eseguire tutte le scritture in un unico batch, ottimizzando il processo di rendering in un singolo "reflow" invece di molti ricalcoli forzati.

Sostituiremo le tue funzioni di traduzione con versioni ottimizzate.

Passo 1: Modifica script.js

Apri il file script.js e sostituisci le funzioni setLanguage e updateMetaTags con le seguenti versioni ottimizzate. Ho anche modificato initLanguageSelector per chiamare la nuova funzione.

code
JavaScript
download
content_copy
expand_less

// --- INIZIO NUOVO CODICE OTTIMIZZATO ---

// Sostituisci la tua funzione initLanguageSelector esistente con questa
function initLanguageSelector() {
    console.log('🌐 Initializing language selector...');
    const currentLang = localStorage.getItem('selectedLanguage') || 'it';
    console.log('🏁 Current language:', currentLang);

    // Esegui la traduzione ottimizzata
    setLanguageOptimized(currentLang);
    updateActiveLanguageButton(currentLang);

    DOM.langButtons.forEach(button => {
        button.addEventListener('click', function() {
            const selectedLang = this.getAttribute('data-lang');
            console.log('🖱️ Language button clicked:', selectedLang);
            setLanguageOptimized(selectedLang);
            updateActiveLanguageButton(selectedLang);
            localStorage.setItem('selectedLanguage', selectedLang);
        });
    });
}

// NUOVA FUNZIONE OTTIMIZZATA: Sostituisce setLanguage e updateMetaTags
function setLanguageOptimized(lang) {
    console.log(`🔄 Setting language to ${lang} (Optimized)`);
    const operations = []; // Array per memorizzare le operazioni sul DOM

    // --- FASE DI LETTURA (READ BATCH) ---
    // Leggiamo tutto ciò di cui abbiamo bisogno dal DOM senza modificarlo.
    
    // 1. Lettura per la traduzione dei contenuti
    const elementsToTranslate = document.querySelectorAll('[data-translate]');
    elementsToTranslate.forEach(element => {
        const key = element.getAttribute('data-translate');
        if (translations[lang] && translations[lang][key]) {
            operations.push({
                element: element,
                action: 'translate',
                content: translations[lang][key]
            });
        }
    });

    // 2. Lettura per i placeholder
    const placeholderElements = document.querySelectorAll('[data-translate-placeholder]');
    placeholderElements.forEach(element => {
        const key = element.getAttribute('data-translate-placeholder');
        if (translations[lang] && translations[lang][key]) {
            operations.push({
                element: element,
                action: 'placeholder',
                content: translations[lang][key]
            });
        }
    });

    // 3. Lettura per i meta tag (solo su index.html)
    const currentPath = window.location.pathname;
    const isHomepage = currentPath === '/' || currentPath.endsWith('/index.html');
    if (isHomepage) {
        const metaMapping = {
            'meta[name="description"]': translations[lang]['index-meta-description'],
            'meta[property="og:title"]': translations[lang]['index-og-title'],
            'meta[property="og:description"]': translations[lang]['index-og-description'],
            'meta[name="twitter:title"]': translations[lang]['index-twitter-title'],
            'meta[name="twitter:description"]': translations[lang]['index-twitter-description'],
            'title': translations[lang]['page-title']
        };
        for (const selector in metaMapping) {
            const element = document.querySelector(selector);
            if (element && metaMapping[selector]) {
                operations.push({
                    element: element,
                    action: 'meta',
                    content: metaMapping[selector]
                });
            }
        }
    }

    // --- FASE DI SCRITTURA (WRITE BATCH) ---
    // Usiamo requestAnimationFrame per assicurarci che tutte le scritture avvengano
    // in un unico batch, ottimizzato dal browser.
    requestAnimationFrame(() => {
        console.log(`✍️ Executing ${operations.length} DOM write operations.`);
        
        operations.forEach(op => {
            switch (op.action) {
                case 'translate':
                    if (op.element.tagName === 'INPUT' || op.element.tagName === 'TEXTAREA') {
                        op.element.placeholder = op.content;
                    } else {
                        op.element.innerHTML = op.content;
                    }
                    break;
                case 'placeholder':
                    op.element.placeholder = op.content;
                    break;
                case 'meta':
                     if (op.element.tagName === 'TITLE') {
                        op.element.textContent = op.content;
                    } else {
                        op.element.setAttribute('content', op.content);
                    }
                    break;
            }
        });

        // Scritture finali sugli attributi globali
        document.documentElement.lang = lang;
        let ogLocale = document.querySelector('meta[property="og:locale"]');
        if (ogLocale) {
            ogLocale.setAttribute('content', lang === 'en' ? 'en_US' : 'it_IT');
        }
        
        console.log('✅ DOM updates completed.');
    });
}


// QUESTA FUNZIONE NON SERVE PIÙ, LA LOGICA È STATA INTEGRATA
// function updateMetaTags(lang) { ... } // Puoi commentarla o cancellarla

// QUESTA FUNZIONE NON SERVE PIÙ, LA LOGICA È STATA INTEGRATA
// function setLanguage(lang) { ... } // Puoi commentarla o cancellarla

// ASSICURATI DI MANTENERE QUESTA FUNZIONE SEPARATA
function updateActiveLanguageButton(lang) {
    const langButtons = document.querySelectorAll('.lang-btn');
    langButtons.forEach(button => {
        button.classList.remove('active');
        if (button.getAttribute('data-lang') === lang) {
            button.classList.add('active');
        }
    });
}


// --- FINE NUOVO CODICE OTTIMIZZATO ---
Passo 2: Pulizia del file script.js

Rimuovi le vecchie funzioni: Dopo aver incollato il nuovo codice, cancella o commenta le tue vecchie funzioni initLanguageSelector, setLanguage, updateMetaTags e updatePageLanguageAttributes per evitare duplicati e confusione.

Rimuovi il codice non utilizzato: Ho notato che hai delle implementazioni per domCache e domOperations all'inizio del file. Queste sono ottime idee ma non vengono attualmente utilizzate dal resto del codice. Per ora, puoi lasciarle o rimuoverle per pulizia. La mia soluzione setLanguageOptimized implementa lo stesso principio in modo autocontenuto e più semplice.

Perché Questa Soluzione Funziona

Batching delle Operazioni: La nuova funzione setLanguageOptimized prima esegue un "batch di lettura": colleziona tutti gli elementi e i nuovi contenuti in un semplice array (operations) senza toccare il DOM.

Scrittura Sincronizzata: Successivamente, affida l'intero array di modifiche a requestAnimationFrame. Questo dice al browser: "Ehi, ho un gruppo di modifiche da fare. Fai pure quando sei pronto, durante il tuo prossimo ciclo di rendering."

Eliminazione del Reflow Forzato: Il browser riceve tutte le istruzioni di scrittura insieme. Può calcolare il nuovo layout una sola volta in modo efficiente. Non ci sono più letture (querySelector) che interrompono il processo di scrittura, eliminando così la causa principale dell'errore.

Logica Unificata: La logica per aggiornare i meta tag è stata integrata direttamente nella funzione principale, rendendo il codice più pulito e assicurando che anche queste operazioni vengano eseguite nel batch corretto.

Dopo aver implementato queste modifiche, l'errore "Adattamento dinamico forzato del contenuto" dovrebbe scomparire o ridursi drasticamente nei report di PageSpeed, migliorando tangibilmente il tempo di rendering iniziale della pagina.
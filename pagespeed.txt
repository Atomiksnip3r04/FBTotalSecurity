Analizzando il tuo codice CSS, ho identificato il problema principale e posso offrirti una soluzione elegante che risolve tutti i problemi menzionati.

## Il Problema

Il conflitto di containing block è causato da `backdrop-filter` sull'header che crea un nuovo contesto di posizionamento. Quando il menu mobile ha `position: fixed` con `bottom: 0`, cerca di estendersi fino al fondo del suo contenitore (l'header) invece che del viewport.

## La Soluzione CSS

Ecco la soluzione completa che risolve tutti i problemi:

```css
/* Soluzione per mobile menu - aggiungi questo al tuo CSS */
@media (max-width: 768px) {
    /* Rimuovi il backdrop-filter dall'header su mobile quando il menu è aperto */
    .header:has(.nav-menu.active) {
        backdrop-filter: none !important;
        transition: backdrop-filter 0s; /* Transizione istantanea per evitare flash */
    }
    
    /* Se il browser non supporta :has(), usa questa alternativa con JavaScript */
    .header.menu-open {
        backdrop-filter: none !important;
        transition: backdrop-filter 0s;
    }
    
    .nav-menu {
        position: fixed;
        top: 82px;
        left: 0;
        right: 0;
        /* Rimuovi bottom: 0 e usa min-height invece */
        min-height: calc(100vh - 82px);
        height: auto; /* Permetti al contenuto di determinare l'altezza */
        width: 100%;
        background: rgba(30, 30, 30, 0.98);
        
        /* Flexbox per allineare il contenuto in alto */
        display: flex;
        flex-direction: column;
        justify-content: flex-start; /* Allinea le voci in alto */
        align-items: center;
        padding: 2rem 0;
        
        /* Animazioni */
        transform: translateY(-100%);
        opacity: 0;
        visibility: hidden;
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), 
                    opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                    visibility 0s 0.3s; /* Delay sulla visibility per evitare flash */
        
        z-index: 10000;
        
        /* Il proprio backdrop-filter compensa quello rimosso dall'header */
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        
        border-radius: 0 0 20px 20px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        
        /* Previeni scrollbar interna */
        overflow-y: auto;
        overflow-x: hidden;
        
        /* Smooth scrolling se necessario */
        -webkit-overflow-scrolling: touch;
    }

    .nav-menu.active {
        transform: translateY(0);
        opacity: 1;
        visibility: visible;
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), 
                    opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                    visibility 0s; /* Nessun delay quando si apre */
    }
    
    /* Pseudo-elemento per estendere lo sfondo se necessario */
    .nav-menu::after {
        content: '';
        position: fixed;
        top: 82px;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(30, 30, 30, 0.98);
        z-index: -1;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s ease;
    }
    
    .nav-menu.active::after {
        opacity: 1;
    }
    
    /* Assicura che i link siano ben spaziati e allineati */
    .nav-link {
        width: 100%;
        text-align: center;
        padding: 1rem 2rem;
        margin: 0.25rem 0;
    }
}
```

## Implementazione JavaScript Complementare (se necessario)

Se il browser non supporta `:has()`, aggiungi questo JavaScript per gestire la classe sull'header:

```javascript
// Aggiungi questo al tuo JavaScript esistente
const hamburger = document.querySelector('.hamburger');
const navMenu = document.querySelector('.nav-menu');
const header = document.querySelector('.header');

hamburger.addEventListener('click', () => {
    hamburger.classList.toggle('active');
    navMenu.classList.toggle('active');
    // Aggiungi/rimuovi classe sull'header per la soluzione CSS
    header.classList.toggle('menu-open');
});
```

## Spiegazione della Soluzione

1. **Rimozione dinamica del backdrop-filter**: Quando il menu è attivo, rimuoviamo temporaneamente il `backdrop-filter` dall'header, eliminando il containing block problematico.

2. **Min-height invece di bottom**: Usando `min-height: calc(100vh - 82px)` invece di `bottom: 0`, il menu si estende correttamente senza creare una scrollbar interna.

3. **Flexbox con justify-content: flex-start**: Allinea le voci del menu in alto invece che al centro.

4. **Pseudo-elemento ::after**: Fornisce uno sfondo di backup che copre l'intero viewport se necessario.

5. **Transizioni ottimizzate**: La `visibility` ha un delay solo quando si chiude, prevenendo flash durante l'apertura.

Questa soluzione mantiene l'effetto blur desiderato, previene il layout shift, e garantisce che il menu funzioni correttamente su tutti i dispositivi mobile.